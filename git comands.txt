1. $ git init - инициализация нового гит-репозитория, переиндексация уже существующего.

2. $ git clone [url] - клонирование удаленного репозитория с хостинга, делается единоразовано.

3. $ git add - проиндексировать файл, подготовить к коммиту, добавить к версионному контролю (отслеживанию).
   $ git add <file.name> - индексация (stage) конкретного файла.
   $ git add -A / git add - индексация всех файлов в активном каталоге.

4. $ git status - получает список всех изменений с файлами в репозитории.

5. $ git commit - фиксирует снимок проиндексированного изменения.
   $ git commit [-a/<file>/-m "message"] - вместо git add/выбранный файл/коммит прям в строке, бед редактора.
   $ git commit --amend -m "message for last commit before pushed" - отредактировать коммент последнего коммита.
     --ammend позволяет "отредактировать" последний коммит, т.е, можно внести "забытые" правки в тот же самый коммит.
   
6. $ touch .gitignore - создали игнор-лист (текстовый файл без расширений).
   $ git add .gitignore - проиндексировали.
   $ git commit .gitignore -m "message commit" - закоммитили и забыли.
 
7. $ git diff - показать, что именно было изменено в индексированном файле перед коммитом; показать изменения в, изменненном неиндексированном, файле (но отслеживаемом).
   $ git diff --cached - показать, что проиндексировано и войдёт в следующий коммит.
   $ git diff --staged - то же самое, что --cached, но для новых версий гита.
   
8. $ git rm --cached <file> - удаление файла из индекса, но оставить в рабочей области.
   $ rm <file> - удаление файла без пометки в индекс; git add/rm <file> добавит изменения для коммита.
   $ git checkout  <file> отменит изменения в рабочей области.
   $ rm -rf .git - рекурсивно удаляет папку локального репозитория.
  
   $ git rm <file> - удаление файла из рабочей области (аналог из индекс + коммит).
     восстановить можно reset + checkout (удалить из индекса и отменить изменения).
   
9. $ git reset HEAD <file> - удалить из индекса (начинает закипать мозг).

10. $ git mv <old file name> <new file name> - неявно переименовывает выбранный файл и сразу добавляет в индекс.

11. $ git remote - просмотр подключенных настроенных удаленных репозиториев.
    $ git remote -v - просмоср с сопоставление краткого имени и полного пути.
    $ git remote show [удал. сервер] - получение информации об удаленном репозитории.

12. $ git remote add [сокращение] [url]: - добавление удаленного репозитория.

13  $ git fetch [имя удал. сервера] - забрать все данные с указанного сервера.
    $ git fetch origin - забрать все, если сервер был ранее склонирован. Т.к., при origin присвается при git clone.
    # после fetch всегда нужно вручную делать merge с выбранной локальной веткой.
      
14. $ git push [удал. сервер] [ветка] - отправка данных на удаленный репозиторий определенную ветку.
    $ git push origin <local.branch.name>:<server.branch.name> - отправить локальную ветку на сервер с указанным именем
    $ git push origin :<server.branch.name> - удалить ветку в удаленном репозитории.
    $ git push origin master - когда надо отправить ветку мастер на origin.

15. $ git pull - когда есть ветка, настроенная на отслеживание удалённой ветки (fetch + merge на активную ветку). 

16. Чтобы пользоваться SSH, нужно создать пару ключей, добавить в настройках GitHub, связать со своей машиной.
    При правильных настройках, при выполнении операций будет запрашиваться пароль для ключа (хотя это можно обойти).
  
  # Для настройки необходимо выполнить:
    # Запускаем ssh-агента
    $ eval `ssh-agent.exe`
    
    # Создаем ключи (выбор папки, установка пароля на ключ).
    $ ssh-keygen -t rsa -C timofeev.e390@gmail.com
    
    # Добавляем на гитхабе (по-умолчанию in_rsa.pub).
    $ ssh-add
    
    # Подтверждаем аутентификацию
    $ ssh -T git@github.com
    
    После таких настроек базовые операции clone, push, pull проходят корректно, но запрашивает пароль.
    С протоколом HTTPS проще, ключи не нужны.

17. Работа с тэгами. Git использует два основных типа меток: легковесные и аннотированные. Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. А вот аннотированные метки хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий.
    $ git tag - просмотр имеющихся меток.
    $ git tag -a <tag.name> - создание легковесной метки. Без атрибутов. Без доп. инфо. Просто отметка коммита.
    $ git tag -a <tag.name> -m "tag message" - создание аннотированного тэга (режим -a).
    $ git tag -a <tag.name> -m "tag message" <hash.ID ~first 7 chars> - создание аннотированого тэга с указанием контрольной суммы уже пройденного коммита.
    $ git tag -s v1.1 -m "Тэг с подписью" - создание подписанного тэга (режим -s). Требуется создание gpg-ключа.
    # по аналогии с ssh-ключем, требуется генерация, добавление в аккаутн и пшсвязывание с локальной машиной. 
    $ git show <tag.name> - просмотр данных метки вместе с коммитом, который был помечен.
    $ git tag -v <tag.name> - для верификации подписанной метки.
    $ git push origin <tag.name> - отправка в репозиторй конкретной метки.
    $ git push origin --tags - отправка в репозиторй всех меток.

18. Добавление псевдонимов (алиасов) для сокращения команд.
    $ git config --global alias.co checkout - пример сокращения, --global изменения общего гитконфига.
    $ git config --global alias.last 'log -1 HEAD' - алиас для просмотра последнего коммита. куьщеу
    
19. Для переименования папки локального репозитория - просто переименовать.
    Для переименования удаленного репозитория (если изменена ссылка)
    #  изменить на хабе название, тем самым измени URL, а на локальной машине:
      -> $ git remote rm origin
      -> $ git remote add origin #URL нового репозитория
      -> $ git push -u origin
    # Просто переименовать репозиторий так:
      $ git remote rename pb paul
  
20. Углубленная работа с ветками.
    $ git checkout -b <branch.name> - создает новую ветку и сразу переходит на нее (checkout).
    $ git branch - просмотр имеющихся веток.
    $ git branch -d <branch.name> - удаление выбранной локальной ветки (git branch -D <branch.name> - принудительное удаление ветки с неслитыми изменениями)
    $ git merge <branch.name> - слияние текущей ветки с указанной в команде.
    $ git branch -v - просмотр последнего коммита каждой ветки.
    $ git branch --no-merged - просмотр изменений, еще не слитых в текущую ветку.
    $ git checkout - кроме перехода на ветку, ветка становится отслеживаемой.
    $ git checkout -b [ветка] [удал. сервер]/[ветка] - настроить нужную ветку на отслеживание из удаленного репозитория.
    # для git 1.6.2 и выше аналог git checkout --track origin/<branch.name>.
    $ git checkout -b <local.branch.name> origin/<server.branch.name> - настроить локальную ветку с именем, отличным от имени удалённой ветки.
    
    # rebase (перемещение) выполнять только для незапушенных коммитов, иначе будет путаница для остальных участников команды.

21. Обзор Git-протоколов.
    Рассмотрены существующие протоколы Git для организации Git-сервера: преимущества и недостатки.
    # Локальный - круто при использовании общей системы сетевых папок, не айс для остальных случаев.
    # SSH - наиболее часто используемый сетевой протокол дающий права Read/Write. Есть аутентификация, простая настройка. И хорошо и пригож, но не подходит для анонимного доступа к репозиторию, если речь идет об open sourse.
    # Git-протокол - похож на SSH, но без авторизации, самый быстрый. Требует настройки git-демона для прослушивания порта 9418 (вот он редиска, который мне мофк сломал. И вообще самый сложный протокол для настройки.
    # Протокол HTTP/S - самый быстрый и простой для настройки. Нужен веб-сервер и установка перехватчика post-update. И все. Используется редко.

22. Порядок с историей.
    
    # Определяем вносимые изменения.
    $ git log <branch1> --not <branch2> - исключение просмотра логов ветки branch2.
    $ git log -p - к какжому коммиту добавить его diff.
    $ git diff master - полный diff того, что добавится при слиянии одной тематической ветки с другой веткой.

23. Инструменты Git.
    
    # 1. Выбор ревизии.
    $ git show <hash> - просмотр содержимого коммита по конкретного хэшу. Достаточно первых 4-5 однозначных символов.
    $ git log --abbrev-commit --pretty=oneline - 1-е вывод будет использовать сокращённые значения, сохраняя их уникальными. 2-е компактный вывод.
    $ git reflog - просмотр ссылочного лога, де находились HEAD и ветки в течение последних нескольких месяцев.
    $ git show HEAD@{n} - просмотр какое значение было у HEAD в репозитории n шагов назад.
    $ git show master@{yesterday} - просмотр, где была ветка некоторое время назад.
    
    # 2. Интерактивное индексирование.
    $ git add -i - мощная штука с менюшкой по операциям индексирования.
    
    # 3. Прятанье.
    
    $ git stash - Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек             незавершённых изменений, которые вы потом в любое время можете снова применить.
    $ git stash apply - применить спрятанные изменения.
    $ git stash apply stash@{n} - применить кокнретное изменение.
    $ git stash list - просмотр спрятанных изменений.
    $ git stash branch <tmp.branch.name> - создание отдельной ветки из спрятанного состояния.
    $ git stash drop - удаление из стека спрятанного.
    
    # 4. Перезапись истории.
    
    $ git commit --amend - редактирование сообщения последнего коммита.
      много сложных команд, надо разбираться по факту.
    
    # 5. Отладка с помощью Git.
    
    $ git blame (git blame -L n,m) file - аннотация файла. Просмотр, кто и когда изменил файл построчно. -L можно ограничить вывод с n по m строку. 
    $ git blame -С file - позволяет понять откуда пояивлись изменения в аннотируемом файле изначально, если они были откуда-то скопированы.
    
    # Механизмы бинарного поиска для локализации ошибок, которую не ясно откуда ловить.
     
    $ git bisect start - запуска процесса.
    $ git bisect bad - стопарим, указывая, что текущий коммит сломан (то состояние, где мы смогли воспроивести баг, но не знаем, когда он появился).
    $ git bisect good v1.0 - указываем предположительно тот коммит, когда все работало.
     
    # И так рекурсивно ищем, пока не найдем сломанный комимит, чтобы знать, что и где менять.
    # Найденный плохой коммит помечаем git bisect bad, после, делаем git bisect reset, чтобы сбросить HEAD туда, где он был до начала бинарного поиска.
    # Можно сделать скрипт для проверки каждого выгружаемого коммита.
    
    # Подмодули (submodule).
    # Для работы надо задать для конфига: git config --global core.safecrlf false.
    
    
    
    
    
