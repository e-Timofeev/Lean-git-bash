>> Все ключевые команды для работы в консоли, инкапсулированы в различных клиентах в виде GUI.

1. $ git init - инициализация нового гит-репозитория, переиндексация уже существующего.

2. $ git clone [url] - клонирование удаленного репозитория с хостинга, делается единоразово.

3. $ git add - проиндексировать файл, подготовить к коммиту, добавить к версионному контролю (отслеживанию).
   $ git add <file.name> - индексация (stage) конкретного файла.
   $ git add -A / git add - индексация всех файлов в активном каталоге.

4. $ git status - получает список всех изменений с файлами в локальном репозитории.

5. $ git commit - фиксирует снимок проиндексированного изменения.
   $ git commit [-a/<file>/-m "message"] - вместо git add/выбранный файл/коммит прям в строке команды, бед открытия редактора.
   $ git commit --amend -m "message for last commit before pushed" - отредактировать коммент последнего коммита.
     --ammend позволяет "отредактировать" последний коммит, т.е, можно внести "забытые" правки в тот же самый коммит.
   
6. $ touch .gitignore - создание игнор-листа (текстовый файл без расширений).
   $ git add .gitignore - проиндексировали.
   $ git commit .gitignore -m "message commit" - закоммитили и забыли.
 
7. $ git diff - показать, что именно было изменено в индексированном файле перед коммитом; показать изменения в измененном, не индексированном, но отслеживаемом файле.
   $ git diff --cached - показать, что проиндексировано и войдёт в следующий коммит.
   $ git diff --staged - то же самое, что --cached, но для новых версий гита.
   
8. $ git rm --cached <file> - удаление файла из индекса, но оставить в рабочей области.
   $ rm <file> - удаление файла без пометки в индекс. 
   $ git add/rm <file> добавить изменения для коммита.
   $ git checkout <file> отменить изменения в рабочей области.
   $ rm -rf .git - рекурсивно удаляет папку локального репозитория.
   $ git rm <file> - удаление файла из рабочей области (аналог из индекс + коммит).
     восстановить можно reset + checkout (удалить из индекса и отменить изменения).
   
9. $ git reset HEAD <file> - удалить из индекса (т.е., то, что на подготовлено к коммиту).

10. $ git mv <old file name> <new file name> - неявно переименовывает выбранный файл и сразу добавляет в индекс.

11. $ git remote - просмотр подключенных и настроенных удаленных репозиториев.
    $ git remote -v - просмоср с сопоставлением краткого имени и полного пути.
    $ git remote show [удал. сервер] - получение информации об удаленном репозитории.
    $ git remote add [сокращение] [url]: - добавление удаленного репозитория.

12  $ git fetch [имя удал. сервера] - забрать все данные с указанного сервера.
    $ git fetch origin - забрать все, если сервер был ранее склонирован. Т.к., origin присваивается при git clone.
    # после fetch всегда нужно вручную делать merge с выбранной локальной веткой.
      
13. $ git push [удал. сервер] [ветка] - отправка данных на удаленный репозиторий определенной ветки.
    $ git push origin <local.branch.name>:<server.branch.name> - отправить локальную ветку на сервер с указанным именем.
    $ git push origin :<server.branch.name> - удалить ветку в удаленном репозитории.
    $ git push origin master - когда надо отправить ветку мастер на origin.

14. $ git pull - когда есть ветка, настроенная на отслеживание удалённой ветки (fetch + merge на активную ветку).

15. Чтобы пользоваться SSH, нужно создать пару ключей, добавить в настройках GitHub, связать со своей машиной.
    При правильных настройках, при выполнении операций будет запрашиваться пароль для ключа (хотя это можно обойти).
  
  # Для настройки необходимо выполнить:
    # Запускаем ssh-агента
    $ eval `ssh-agent.exe`
    
    # Создаем ключи (выбор папк11:02 30.03.2018и, установка пароля на ключ).
    $ ssh-keygen -t rsa -C timofeev.e390@gmail.com
    
    # Добавляем на гитхабе (по-умолчанию in_rsa.pub).
    $ ssh-add
    
    # Подтверждаем аутентификацию
    $ ssh -T git@github.com
    
    После таких настроек базовые операции clone, push, pull проходят корректно, но запрашивает пароль.
    С протоколом HTTPS проще, ключи не нужны.

17. Работа с тэгами. Git использует два основных типа меток: легковесные и аннотированные. Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. А вот аннотированные метки хранятся в базе данных Git'а, как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий.
    $ git tag - просмотр имеющихся меток.
    $ git tag -a <tag.name> - создание легковесной метки. Без атрибутов. Без доп. инфо. Просто отметка коммита.
    $ git tag -a <tag.name> -m "tag message" - создание аннотированного тэга (режим -a).
    $ git tag -a <tag.name> -m "tag message" <hash.ID ~first 7 chars> - создание аннотированого тэга с указанием контрольной суммы уже пройденного коммита.
    $ git tag -s v1.1 -m "Тэг с подписью" - создание подписанного тэга (режим -s). Требуется создание gpg-ключа.
    # по аналогии с ssh-ключем, требуется генерация, добавление в аккаунт и связывание с локальной машиной. 
    $ git show <tag.name> - просмотр данных метки вместе с коммитом, которым он был помечен.
    $ git tag -v <tag.name> - для верификации подписанной метки.
    $ git push origin <tag.name> - отправка в репозиторий конкретной метки.
    $ git push origin --tags - отправка в репозиторий всех меток.

18. Добавление псевдонимов (алиасов) для сокращения команд.
    $ git config --global alias.co checkout - пример сокращения, --global изменения общего гитконфига.
    $ git config --global alias.last 'log -1 HEAD' - алиас для просмотра последнего коммита.
    
19. Для переименования папки локального репозитория - просто переименовать.
    Для переименования удаленного репозитория (если изменена ссылка)
    #  изменить на хабе название, тем самым изменить URL, а на локальной машине:
      -> $ git remote rm origin
      -> $ git remote add origin #URL нового репозитория
      -> $ git push -u origin
    # Просто переименовать репозиторий так:
      $ git remote rename pb paul
  
20. Углубленная работа с ветками.
    $ git checkout -b <branch.name> - создает новую ветку и сразу переходит на нее (checkout).
    $ git branch - просмотр имеющихся веток.
    $ git branch -d <branch.name> - удаление выбранной локальной ветки (git branch -D <branch.name> - принудительное удаление ветки с не слитыми изменениями)
    $ git merge <branch.name> - слияние текущей ветки с указанной в команде.
    -- Алгоритм работы с ветками:
     1. Создали новую ветку, арбайтен в ней. Коммит.
     2. После завершения работы, находясь на новой ветке, подтянуть через Merge изменения из основной ветки. Чтобы проверить отсутствие конфликтов, которые, в случае чего, можно решить вручную через Conflict Solver, с последующим Stage.
     3. После этого переходим в основную ветку и делаем Merge с дополнительной.
     4. Удаляем новую ветку. Пушим в удаленный репозиторий.
     
    $ git branch -v - просмотр последнего коммита каждой ветки.
    $ git branch --no-merged - просмотр изменений, еще не слитых в текущую ветку.
    $ git checkout - кроме перехода на ветку, ветка становится отслеживаемой.
    $ git checkout -b [ветка] [удал. сервер]/[ветка] - настроить нужную ветку на отслеживание из удаленного репозитория.
    # для git 1.6.2 и выше аналог git checkout --track origin/<branch.name>.
    $ git checkout -b <local.branch.name> origin/<server.branch.name> - настроить локальную ветку с именем, отличным от имени удалённой ветки.   
    # rebase (перемещение) выполнять только для незапушенных коммитов, иначе будет путаница в иерархии коммитов для остальных участников команды.

21. Обзор Git-протоколов.
    Рассмотрены существующие протоколы Git для организации Git-сервера: преимущества и недостатки.
    # Локальный - круто при использовании общей системы сетевых папок, не айс для остальных случаев.
    # SSH - наиболее часто используемый сетевой протокол дающий права Read/Write. Есть аутентификация, простая настройка. И хорош и пригож, но не подходит для анонимного доступа к репозиторию, если речь идет об open sourse.
    # Git-протокол - похож на SSH, но без авторизации, самый быстрый. Требует настройки git-демона для прослушивания порта 9418. Самый сложный протокол для настройки.
    # Протокол HTTP/S - самый быстрый и простой для настройки. Нужен веб-сервер и установка перехватчика post-update. И все. Используется редко.

22. Порядок с историей.
    
    # Определяем вносимые изменения.
    $ git log <branch1> --not <branch2> - исключение просмотра логов ветки branch2.
    $ git log -p - к какжому коммиту добавить его diff.
    $ git diff master - полный diff того, что добавится при слиянии одной тематической ветки с другой веткой.

23. Инструменты Git.
    
    # 1. Выбор ревизии.
    $ git show <hash> - просмотр содержимого коммита по конкретного хэшу. Достаточно первых 4-5 однозначных символов.
    $ git log --abbrev-commit --pretty=oneline - 1-е вывод будет использовать сокращённые значения, сохраняя их уникальными. 2-е компактный вывод.
    $ git reflog - просмотр ссылочного лога, где находились HEAD и ветки в течении последних нескольких месяцев.
    $ git show HEAD@{n} - просмотр какое значение было у HEAD в репозитории n шагов назад.
    $ git show master@{yesterday} - просмотр, где была ветка некоторое время назад.
    
    # 2. Интерактивное индексирование.
    $ git add -i - мощная штука с менюшкой по операциям индексирования.
    
    # 3. Прятанье.
    
    $ git stash - Прятанье поглощает грязное состояние рабочего каталога, то есть изменённые отслеживаемые файлы и изменения в индексе, и сохраняет их в стек незавершённых изменений, которые вы потом в любое время можете снова применить.
    $ git stash apply - применить спрятанные изменения.
    $ git stash apply stash@{n} - применить кокнретное изменение.
    $ git stash list - просмотр спрятанных изменений.
    $ git stash branch <tmp.branch.name> - создание отдельной ветки из спрятанного состояния.
    $ git stash drop - удаление из стека спрятанного.
    
    # 4. Перезапись истории.
    
    $ git commit --amend - редактирование сообщения последнего коммита (вроде, только если не успели запушить).
    - много сложных команд, надо разбираться по факту.
    
    # 5. Отладка с помощью Git.
    
    $ git blame (git blame -L n,m) file - аннотация файла. Просмотр, кто и когда изменил файл построчно. -L можно ограничить вывод с n по m строку. 
    $ git blame -С file - позволяет понять откуда пояивлись изменения в аннотируемом файле изначально, если они были откуда-то скопированы.
    
    # Механизмы бинарного поиска для локализации ошибок, которую не ясно откуда ловить.
     
    $ git bisect start - запуска процесса.
    $ git bisect bad - стопарим, указывая, что текущий коммит сломан (то состояние, где мы смогли воспроивести баг, но не знаем, когда он появился).
    $ git bisect good v1.0 - указываем предположительно тот коммит, когда все работало.
     
    # И так рекурсивно ищем, пока не найдем сломанный комимит, чтобы знать, что и где менять.
    # Найденный плохой коммит помечаем git bisect bad, после, делаем git bisect reset, чтобы сбросить HEAD туда, где он был до начала бинарного поиска.
    # Можно сделать скрипт для проверки каждого выгружаемого коммита.
    
    # Подмодули (submodule).
    # Для работы надо задать для конфига: git config --global core.safecrlf false.
    $ git submodule add <адрес>.git <имя модуля> - Добавление внешних проектов в качестве подмодулей.
    
    # Клонирование проекта с подмодулями.
    
    $ git clone <адрес репа>.git
    # каталог подмолуля есть, но пустой.
    $ git submodule init -  для инициализации локального файла конфигурации.
    $ git submodule update - для для получения всех данных из подмодуля и перехода к соответствующему коммиту, указанному в основном проекте.
    $ git submodule update - для для получения всех данных из подмодуля и перехода к соответствующему коммиту, указанному в основном проекте.
